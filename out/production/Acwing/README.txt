前提：在已有的相对好的方法上提升一点点，加入的代码量是相当大的。
算法程序如何展开
 1. 又简单到复杂
    1.1 验证一步走一步
    1.2 多打印中间结果
 2. 先局部后整体
    2.1没思路时先细分
 3. 先粗糙后精细
    3.1变量更名
    3.2语句合并
    3.3边界处理

1.快排、归并基本思想都是归并
1）确定分界点：q[l],q[r],q[l+r]/2,随机
2）调整范围，<=x 放左边，>=x 放右边
3）递归处理左右两段

2.归并
1）确定分界点 mid
2）递归排序 left，right
3）归并，将两个排好的序列合并成一个有序的序列

3.二分
1）有单调性一定可以二分，但是二分不一定非得有单调性
2）二分要保证区间里是一定有答案的
3）找一个性质满足：1.有没有二段性  2.答案是二段性的分界点

4.高精度
1）高精度 java不需要掌握，java本身就有处理大整数的函数

5.前缀和
问题1：如何求取Si
问题2：Si 用来干嘛的？
1）Si = a1 + a2 + a3 + ..... + ai

6.差分：前缀和的逆运算
有数组a: a1 , a2 , a3, a4, ....ai
构造数组b：b1, b2, b3,.....bi
使得 ai = b1 + b2 + b3 + ....bi (b成为a的差分，a成为b的前缀和)
构造的方法就是 b1 = a1; b2 = a2-a1; b3= a3-a2.....

1）作用在于让数组中[l,r] 的所有元素全部加上c
2）只要b[l] 加上了c，a[l] 到 a[r] 在用b数组求的时候就会自动加上c
3）但你只让[l,r] 的所有元素全部加上c，所以b[r+1] 就要减去c


7.全排列算法：比如给你九个数字，让你进行全排列
最明显的就是 1209题带分数，TutorialClass/class2/fraction.java
暴力枚举出9个数的全排列，然后用一个长度为9的数组保存全排列的结果
从全排列的结果中用两重循环暴力分解出三段，形如下图，通过 i,j将一个排列分割，每段代表一个数



7.动态规划专题 —— DP所分的类型并不多
动态规划的时间复杂度——状态数量 * 转移的计算量
背包问题专题—— 为什么这么推导的流程搞清楚
1）01背包问题——每件物品最多只使用一次

2）完全背包问题——每件物品有无限个

3）多重背包问题——每个物品有 s[i] 个

4）分组背包问题—— N组每组物品里有若干个，每一组里只能选择一项物品，限制条件下问最大价值


线性DP——递推的顺序有一个明显的线性的关系

我们只是把存在的类取一个max，最后一个数是a[i],倒数第2个数是a[j],这样的上升子序列的最大值
整个计算过程的每一步一定是基于之前的结果。
而且需要把每一步的过程保存，这也是一个问题，求最大值的时候分类之间是可以重复的，但求数量的时候是不可以重复的






