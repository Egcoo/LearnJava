前提：在已有的相对好的方法上提升一点点，加入的代码量是相当大的。
算法程序如何展开
 1. 又简单到复杂
    1.1 验证一步走一步
    1.2 多打印中间结果
 2. 先局部后整体
    2.1没思路时先细分
 3. 先粗糙后精细
    3.1变量更名
    3.2语句合并
    3.3边界处理

1.快排、归并基本思想都是归并
1）确定分界点：q[l],q[r],q[l+r]/2,随机
2）调整范围，<=x 放左边，>=x 放右边
3）递归处理左右两段

2.归并
1）确定分界点 mid
2）递归排序 left，right
3）归并，将两个排好的序列合并成一个有序的序列

3.二分
1）有单调性一定可以二分，但是二分不一定非得有单调性
2）二分要保证区间里是一定有答案的
3）找一个性质满足：1.有没有二段性  2.答案是二段性的分界点

4.高精度
1）高精度 java不需要掌握，java本身就有处理大整数的函数

5.前缀和
问题1：如何求取Si
问题2：Si 用来干嘛的？
1）Si = a1 + a2 + a3 + ..... + ai

6.差分：前缀和的逆运算
有数组a: a1 , a2 , a3, a4, ....ai
构造数组b：b1, b2, b3,.....bi
使得 ai = b1 + b2 + b3 + ....bi (b成为a的差分，a成为b的前缀和)
构造的方法就是 b1 = a1; b2 = a2-a1; b3= a3-a2.....

1）作用在于让数组中[l,r] 的所有元素全部加上c
2）只要b[l] 加上了c，a[l] 到 a[r] 在用b数组求的时候就会自动加上c
3）但你只让[l,r] 的所有元素全部加上c，所以b[r+1] 就要减去c


7.全排列算法：比如给你九个数字，让你进行全排列
最明显的就是 1209题带分数，TutorialClass/class2/fraction.java
暴力枚举出9个数的全排列，然后用一个长度为9的数组保存全排列的结果
从全排列的结果中用两重循环暴力分解出三段，形如下图，通过 i,j将一个排列分割，每段代表一个数



7.动态规划专题 —— DP所分的类型并不多
动态规划的时间复杂度——状态数量 * 转移的计算量
背包问题专题—— 为什么这么推导的流程搞清楚
1）01背包问题——每件物品最多只使用一次

2）完全背包问题——每件物品有无限个

3）多重背包问题——每个物品有 s[i] 个

4）分组背包问题—— N组每组物品里有若干个，每一组里只能选择一项物品，限制条件下问最大价值


线性DP——递推的顺序有一个明显的线性的关系
 * 状态表示
 * 1）集合：所有从起点，走到[i,j] 的路径
 * 2）属性：Max
 * 状态计算
 * 1）每一步的状态是如何通过上一步推导出来
整个计算过程的每一步一定是基于之前的结果。
而且需要把每一步的过程保存，这也是一个问题，求最大值的时候分类之间是可以重复的，但求数量的时候是不可以重复的

可能除了直接变成 string数组以外，变成char数组也会好一些

区间DP —— 状态表示某一个区间






蓝桥杯辅导课 (多用草稿纸，少空想)
首先先想想暴力怎么做，然后再想想能不能优化，具体的优化方法还是就按照你会的那点东西
1.重点中的重点：刷题量，调试代码，按时参加模拟赛，ctrl + r = 替换
2.模型少，思维量大，编写实际的代码要AC
3.算法题写的慢是非常正常的，正常来讲写一道算法题也要1-2个小时
4.学习算法的步骤:1.知道这个东西怎么执行的 2.知道为什么是对的
5.观察数据量，确定解决问题算法的时间复杂度
6.小心涉及到数据范围相加的题，这个时候尽量开double倍
7.OI赛制更容易拿分，关键是你要敢想，而且及时止损
8.题目没见过怎么办呢？不影响
常用的小trick
1.9！= 362880
2.2^10 = 1024、2^15 = 32768  2^17 = 131072  2^20 = 1048576(一百万) 2^25 = 3355万 2^30 = 10个亿
    算法的时间复杂度不大的话可以多开一些空间，防止出现卡边界的问题,比如十万数组的问题开到15万参考 egNO.1240
3.64MB大约可以开 一千六百万长度的 int 数组
4.写算法题的过程算法的时间复杂度是一个辅助解题的工具
5.h = Arrays.stream(strings).mapToInt(Integer::parseInt).toArray(); 将字符串数组变为整数数组
   整数变为字符串并求长度：Integer.toString(a[i]).length();
6.将字符串分割为字符串数组以后，可以使用循环的方式复制成int数组，保证数组从1开始
7.先模10，再除以10可以把个位取出来 （int t = x % 10;x /= 10;）
8.几乎所有涉及到日期的问题都会有合法日期的判断 eg:回文日期466 判断日期1229
     * 月份等于0或者不合法，或者天数不合法
     * 月份不是2的时候，日期怎么处理
     * 月份是2的时候怎么处理，关于闰年的判断
9.1)字符串数组可以二次分割 String[] t2 = t1.split(" "); String[] t3 = t2[0].split(":");
  2)时差是带正负的，这样可以更好理解
  3)如果看不懂先别停下来，先去盘一个简单的例子，看看其中有没有什么规律
10.g[i] = br.readLine().toCharArray(); //每次读一行，并将字符串转换为字符数组,适用于二维数组
11.Arrays.fill(dis[i], -1); 可以直接把数组中所有元素置为某一个值
12.int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};//四个方向使用循环
13.遇到大数据量输入的时候每层的末尾换下一层的时候记得读入一个换行符。
14. * 1. (a[i]%K) * 10^j % k == (a[i]) * 10^j % k
    * 2. 负数求余的公式 (k - t) % k)

15.BFS的核心就是使用队列来模拟
    1. 是否越界
    2. 是否已经遍历过了
    3. 是否是边界
    4. 更新你当前遍历的值的状态
    5. 然后将新的状态加入队尾
    6. 满足你的条件就结束
16.填空题技巧
    1）



第一节：递归与递推（涉及到的就是搜索，dfs（深度优先搜索））
1.所有的递归都可以化成一个递归搜索树。当你想不清楚的时候就可以先画一个二叉树。
2.递归最重要的是顺序，一个顺序可以不重不漏地将所有方案找出来
3.递归很重要一个事情就是恢复现场，作为一个父节点必须给左右节点的选择都是一样的。
4.树 --> dfs参数 1)开一个数组记录方案 2)记录从哪个值开始枚举  3)start 当前最小可以从那个数开始枚举
ps:第二节课讲带分数的优化的解法没听懂

第二节课：递推与递归习题课
递归与递推的区别：递归把一个元问题分解成若干个同种子问题；递推：先求子问题，用子问题求原问题
题目类型：给定一个初始状态，给一些可以进行的的操作，问最少需要几步可以把初始状态转换成目标状态。
最常用的解法：BFS

1.顺序任意
2.每个格子最多摁一次
3.只要第一行的操作固定完以后，第二行的操作一定被第一行灯的亮灭状态所唯一确定
4.每一行的操作完全被上一行的状态唯一确定

第三节课：二分与前缀和
遇到一个问题问最小或者最大都可以使用二分来做

整数二分思路
1.找一个区间[L,R],使得答案一定在区间中
2.找一个判断条件，使得该判断条件具有二段性，并且答案一定是二段性的分界点
3.分析终点M在该判断条件下是否成立，如果成立，考虑在那个区间
4.如果更新方式是 R=mid，则不用做任何处理;如果是更新方式是L=mid，则需要在mid+1

实数二分思路
1.可以直接将区间正好分成[L,M] [M,R] 两部分
2.当区间长度足够小的时候就代表已经满足了条件
3. System.out.printf("%.6f%n", l); 可以决定输出几位小数

第四节课——枚举、模拟与排序
不重不漏的顺序 + 优化对代码进行等价变形
枚举
1.根据数据范围来反推时间复杂度，比如数据量是10万，那么最多就只能枚举一个数组，提供了一个新思路

1.找到问题中最重要的变量，一个变量和其他都能建立关系。对于好几个数组的比较可以选择一个标的，以中间的一个数组作为对照组
2.



第五节课——数学知识与DP（化整为零：一个问题划分为若干个子集，化零为整,而且后面的结果一定是复用前面的过程）
数学知识
1.如果 a,b 均是正整数且互质，那么由 ax+by,x≥0,y≥0 不能凑出的最大数是 (a−1)(b−1)−1。
2.
问法无非两种：最值、个数
DP模型：组合模型(背包问题:有限制的选择最优化问题)、路线模型(摘花生)、
序列模型(最长上升子序列)、树模型、状态压缩模型、联通性模型
区间DP：求最大值或者最小值的时候分出的子区间是可以重复求解的，但求数量的时候就不行了


第十节课——双指针、BFS、图论

BFS 引出栈与队列两个非常重要的数据结构，重要在这是计算机中非常重要的两个逻辑（先进先出、先进后出）
栈所对应的是递归，队列对应BFS
bfs 相对于 dfs 可以找到一个最小的步数,而且bfs处理情况十分相似
1. 是否越界
2. 是否已经遍历过了
3. 是否是边界
4. 更新你当前遍历的值的状态
5. 然后将新的状态加入队尾
6. 满足你的条件就结束

第十一节课 —— 贪心（属实玄学 最优 or 短视）
1.跳跃性非常强 2.往往代码比较短，但结论证明很难，往往属于你感觉可以上手做，但极其容易出错 3.多积累模型
但是考试还是要讲求策略，你只需要给出部分解的一个答案即可
1）找相似 2）猜
1.凡是10^5 的贪心往往都是排序
2.几何分组模型

3.区间排序模型
     * 1.先将所有端点按照右端点排序
     * 2.按照排序的顺序扫描每一个线段
     *  1）如果上一个点不在区间中，则选右端点
     *  2) 如果上一个点在区间中，则跳过
4.平均值迭代模型

5.乘积最大值模型：涉及到分情况讨论

6.树形贪心找规律
因为你逻辑上化成树状以后，你的位置是可以随意摆放的，关键还是找规律


第十五节课———数论
1.如何求取最大公约数（欧几里得算法）
（a,b）的最大公约数 == （b 和 a%b）的最大公约数

2.算术基本定理（公理）

3.线性筛法：使用线性的时间复杂度找出质数
